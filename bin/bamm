#!/usr/bin/python
###############################################################################
#                                                                             #
#    BamM.py                                                                  #
#                                                                             #
#    Get info from the BAM                                                    #
#                                                                             #
#    Copyright (C) Michael Imelfort                                           #
#                                                                             #
###############################################################################
#                                                                             #
#    This library is free software; you can redistribute it and/or            #
#    modify it under the terms of the GNU Lesser General Public               #
#    License as published by the Free Software Foundation; either             #
#    version 3.0 of the License, or (at your option) any later version.       #
#                                                                             #
#    This library is distributed in the hope that it will be useful,          #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU        #
#    Lesser General Public License for more details.                          #
#                                                                             #
#    You should have received a copy of the GNU Lesser General Public         #
#    License along with this library.                                         #
#                                                                             #
###############################################################################

__author__ = "Michael Imelfort"
__copyright__ = "Copyright 2014"
__credits__ = ["Michael Imelfort"]
__license__ = "LGPLv3"
__version__ = "0.2.2"
__maintainer__ = "Michael Imelfort"
__email__ = "mike@mikeimelfort.com"
__status__ = "Beta"

###############################################################################
###############################################################################
###############################################################################
###############################################################################

# system imports
import argparse
import sys
import gzip
import mimetypes

# local imports
from bamm.bamParser import BamParser
from bamm.bamMaker import BamMaker, BamScheduler
from bamm.bamExtractor import BamExtractor
from bamm.bammExceptions import *

###############################################################################
###############################################################################
###############################################################################
###############################################################################

def doWork( args ):
    """ Main wrapper"""
    if(args.subparser_name == 'make'):
        # The BamMaker class is able to take care of making fileNames etc
        # this outer wrapper is here to allow us to make multiple BAM files
        # in one go
        # making the class will take care of filenames and make sure that
        # all the parameters are set nicely
        try:
            BS = BamScheduler(args.database,
                              args.alignment_algorithm,
                              args.index_algorithm,
                              paired=args.coupled,
                              interleaved=args.interleaved,
                              singleEnded=args.single,
                              keptFiles=args.kept,
                              keepFiles=args.keep,
                              outputTam=args.output_tam,
                              numThreads=args.threads,
                              maxMemory=args.memory,
                              forceOverwriting=args.force,
                              verbose=args.verbose
                              )
        except InvalidParameterSetException as e:
            printError(e)
            subparsers.choices['make'].print_help()
            sys.exit(1)

        # create indexes if required
        if(args.kept is False):
            BS.BMs[0].makeDatabase()

        # Now make the TAM/BAM file
        BS.makeBams()

        # clean up if we need to
        if args.keep is False and args.kept is False :
            BS.BMs[0].removeDatabase()

    elif(args.subparser_name == 'parse'):
        BP = BamParser(baseQuality=args.base_quality,
                       minLength=args.length,
                       mappingQuality=args.mapping_quality,
                       coverageMode=args.coverage_mode)

        # if called with no mode then just print types to stdout
        if (args.links == "") and (args.coverages == ""):
            doInserts = True
        else:
            doInserts = (args.inserts != "")

        ret = BP.parseBams(args.bamfiles,
                           doLinks=(args.links != ""),
                           doInserts=doInserts,
                           doCovs=(args.coverages != ""),
                           types=args.num_types,
                           threads=args.threads,
                           verbose=args.verbose)
        if ret == 0:
            # print nice stuff out as required
            if doInserts:
                BP.printBamTypes(args.inserts)
            if args.links != "":
                BP.printLinks(args.links)
            if args.coverages != "":
                BP.printCoverages(args.coverages)

    elif(args.subparser_name == 'extract'):

        if args.target_lists == [] or args.bamfiles == []:
            printError('-l and -b arguments are mandatory')
            subparsers.choices['extract'].print_help()
            sys.exit(1)

        try:
            # get the targets in list form, regardless of how they were passed to us
            targets = makeTargetLists(args.target_lists)
            BE = BamExtractor(targets,
                              args.bamfiles,
                              prefix=args.prefix,
                              outFolder=args.out_folder,
                              mixBams=args.mix_bams,
                              mixTargets=args.mix_targets,
                              mixReads=args.mix_reads,
                              ignoreUnpaired=args.ignore_unpaired,
                              shuffle=args.shuffle,
                              bigFile=args.no_gzip,
                              headersOnly=args.headers_only)
        except InvalidParameterSetException as e:
            printError(e)
            subparsers.choices['extract'].print_help()
            sys.exit(1)

        BE.extract(args.threads, args.verbose)

    else:
        printError("Unknown mode '%s'" % args.subparser_name)
        parser.print_help()
        sys.exit(1)

def makeTargetLists(target_lists):
    """Get the lists of targets to hit"""
    # work out if the targets are lists of contig IDs or just contigs
    # assume that if the file is fasta then the first character will be ">"
    # otherwise it must be a list
    targets = []
    for t_list in target_lists:
        try:
            read_open = open
            # handle gzipped files
            mime = mimetypes.guess_type(t_list)
            if mime[1] == 'gzip':
                read_open = gzip.open
        except:
            raise InvalidParameterSetException('Error when guessing targets file mimetype')

        with read_open(t_list, "r") as t_fh:
            tmp_targets = []
            first_line = t_fh.readline()
            try:
                if first_line[0] == ">":
                    t = first_line.rstrip()[1:]
                    if t != "":
                        tmp_targets.append(t)
                    for line in t_fh:
                        if line[0] == ">":
                            t = line.rstrip()[1:]
                            if t != "":
                                tmp_targets.append(t)
                else:
                    t = first_line.rstrip()
                    if t != "":
                        tmp_targets.append(t)
                    for line in t_fh:
                        t = line.rstrip()
                        if t != "":
                            tmp_targets.append(t)

                if len(tmp_targets) == 0:
                    raise InvalidParameterSetException('No targets in list: %s' % t_list)
                targets.append(tmp_targets)
            except:
                raise InvalidParameterSetException('Something is wrong with the supplied targets file')

    if len(targets) == 0:
        raise InvalidParameterSetException('No valid targets supplied')

    return targets

###############################################################################
###############################################################################
###############################################################################
###############################################################################

def printHelp():
    print '''\

              ...::: BamM :::...

    Working with the BAM, not against it...

   -----------------------------------------
                version: %s
   -----------------------------------------

    bamm make     ->  Make TAM/BAM files (sorted + indexed)
    bamm parse    ->  Get coverage profiles / linking reads / orientation types
    bamm extract  ->  Extract reads from BAM files

    USE: bamm OPTION -h to see detailed options
    ''' % __version__

if __name__ == '__main__':
    #-------------------------------------------------
    # intialise the options parser
    parser = argparse.ArgumentParser(add_help=False)
    subparsers = parser.add_subparsers(help="--", dest='subparser_name')

    #-------------------------------------------------
    # make a BAM file
    make_parser = subparsers.add_parser('make',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='make a TAM/BAM file (sorted + indexed)',
                                        description='make a TAM/BAM file (sorted + indexed)',
                                        epilog='''EXAMPLE: bamm make -d contigs.fa.gz -i reads1_shuffled.fq.gz reads2_shuffled.fq.gz -c reads3_1.fq.gz reads3_2.fq.gz -s reads4_singles.fq.gz -t 40
                                               will produce 4 sorted, indexed BAM files with reads mapped onto contigs.fa.gz using 40 threads''')

    make_parser.add_argument("-d", "--database", default=None, help="contigs to map onto (in fasta format)")
    make_parser.add_argument("-i", "--interleaved", nargs='+', default=[], help="map interleaved sequence files (as many as you like) EX: -i reads1_shuffled.fq.gz reads2_shuffled.fq.gz")
    make_parser.add_argument("-c", "--coupled", nargs='+', default=[], help="map paired sequence files (as many sets as you like) EX: -c reads1_1.fq.gz reads1_2.fq.gz reads2_1.fq.gz reads2_2.fq.gz")
    make_parser.add_argument("-s", "--single", nargs='+', default=[], help="map Single ended sequence files (as many as you like) EX: -s reads1_singles.fq.gz reads2_singles.fq.gz")

    make_parser.add_argument("--index_algorithm", default=None, help="algorithm bwa uses for indexing 'bwtsw' or 'is' [None for auto]")
    make_parser.add_argument("--alignment_algorithm", default="mem", help="algorithm bwa uses for alignment 'mem', 'bwasw' or 'aln'")

    make_parser.add_argument("-k", "--keep", action="store_true", default=False,
                           help="keep all the database index files etc after (see also --kept)")
    make_parser.add_argument("-K", "--kept", action="store_true", default=False,
                           help="assume the indices already exist, don't re-make them (and don't delete them) (e.g. previously this script was run with -k/--keep")
    make_parser.add_argument("-f", "--force", action="store_true", default=False,
                           help="force overwriting of index files if they are present")

    make_parser.add_argument("--output_tam", action="store_true", default=False, help="output TAM file instead of BAM file")

    make_parser.add_argument('-v', '--verbose', action="store_true", default=False, help="be verbose")
    make_parser.add_argument("-t", "--threads", type=int, default="1", help="maximum number of threads to use")
    make_parser.add_argument("-m", "--memory", type=int, default=None, help="maximum amount of memory to use per bwa process (default 2GB*number of threads)")

    #-------------------------------------------------
    # determine linking reads
    parse_parser = subparsers.add_parser('parse',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='get bamfile type and/or coverage profiles and/or linking reads',
                                        description='get bamfile type and/or coverage profiles and/or linking reads')
    parse_parser.add_argument('bamfiles', nargs='+', help="bam files to parse")
    parse_parser.add_argument('-l', '--links', help="filename to write pairing links to", default="")
    parse_parser.add_argument('-i', '--inserts', help="filename to write bamfile insert distributions to", default="")
    parse_parser.add_argument('-c', '--coverages', help="filename to write coverage profiles to", default="")

    parse_parser.add_argument('-n', '--num_types', nargs='+', help="number of insert/orientation types per BAM", type=int)
    parse_parser.add_argument('-m', '--coverage_mode', help="how to calculate coverage (requires --coverage)", default='vanilla', choices=['vanilla', 'outlier'])

    parse_parser.add_argument('-L', '--length', help="minimum Q length", type=int, default=50)
    parse_parser.add_argument('-q', '--base_quality', help="base quality threshold (Qscore)", type=int, default=20)
    parse_parser.add_argument('-Q', '--mapping_quality', help="mapping quality threshold", type=int, default=0)

    parse_parser.add_argument('-v', '--verbose', action="store_true", default=False, help="be verbose")
    parse_parser.add_argument('-t', '--threads', help="maximum number of threads to use", type=int, default=1)

    #-------------------------------------------------
    # read extractor
    extract_parser = subparsers.add_parser('extract',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='extract reads from bamfile(s)',
                                        description='Extract reads which hit the given references',
                                        epilog='-t and -b arguments are mandatory')
    extract_parser.add_argument('-l', '--target_lists', nargs='+', default=[], help="files containing reference names (1 per line) or contigs file in fasta format")
    extract_parser.add_argument('-b', '--bamfiles', nargs='+', default=[], help="bam files to parse")

    extract_parser.add_argument('-p', '--prefix', default="", help="prefix to apply to output files")
    extract_parser.add_argument('-o', '--out_folder', default=".", help="write to this folder")

    extract_parser.add_argument('--mix_bams', action="store_true", default=False, help="use the same file for multiple bam files")
    extract_parser.add_argument('--mix_targets', action="store_true", default=False, help="use the same files for multiple target groups")
    extract_parser.add_argument('--mix_reads', action="store_true", default=False, help="use the same files for paired/unpaired reads")
    extract_parser.add_argument('--ignore_unpaired', action="store_true", default=False, help="ignore unpaired reads")
    extract_parser.add_argument('--shuffle', action="store_true", default=False, help="shuffle paired reads in ouput files")

    extract_parser.add_argument('--no_gzip', action="store_true", default=False, help="do not gzip output files")
    extract_parser.add_argument('--headers_only', action="store_true", default=False, help="extract only (unique) headers")

    extract_parser.add_argument('-v', '--verbose', action="store_true", default=False, help="be verbose")
    extract_parser.add_argument('-t', '--threads', help="maximum number of threads to use", type=int, default=1)

    #-------------------------------------------------
    # get and check options
    args = None
    if(len(sys.argv) == 1):
        printHelp()
        sys.exit(0)
    elif(sys.argv[1] == '-v' or sys.argv[1] == '--version'):
        print "BamM: version %s %s %s" % (__version__, __copyright__, __author__)
        sys.exit(0)
    elif(sys.argv[1] == '-h' or sys.argv[1] == '--help'):
        printHelp()
        sys.exit(0)
    else:
        args = parser.parse_args()

    # profiling happens here. If you'd like to track the speed your code runs at
    # then set the following to True and voila!
    if(False):
        import cProfile
        cProfile.run('doWork(args)', 'profile')
        ##########################################
        ##########################################
        # Use this in python console!
        #import pstats
        #p = pstats.Stats('prof')
        #p.sort_stats('cumulative').print_stats(10)
        #p.sort_stats('time').print_stats(10)
        ##########################################
        ##########################################
    else:
        doWork(args)

###############################################################################
###############################################################################
###############################################################################
###############################################################################

